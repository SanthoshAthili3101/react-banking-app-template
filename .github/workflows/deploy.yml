name: React App Deployment

# Triggers
on:
  push:
    branches: [master]

  # Allows you to run this manually from the Actions tab for debugging
  workflow_dispatch:

# Concurrency (it will delete the exisiting pipeline runs if a new one is triggered)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Global environment variables
env:
  aws_region: ap-south-1
  ECR_REPOSITORY:  react-banking-app
  IMAGE_TAG: ${{ github.sha }}

# Permissions
permissions:
  contents: read
  security-events: write # For uploading scan results to GitHub 

# Jobs
jobs:
  build-secure-deploy:
    name: Build, Secure, Optimize and Deploy 
    runs-on: ubuntu-latest

    steps:
    #stage 1: Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for accurate SHA tagging and to scan all commits
    
    # Stage 2: Secret Scanning (TruffleHog)
    # Checks git history for leaked AWS keys, tokens, etc.
    - name: Secret Scanning with TruffleHog
      uses: trufflesecurity/trufflehog-action@v3
      with:
        extra_args: --only-verified
        exit_code: '1'  # Fail the job if secrets are found

    # Stage 3: SAST( STATIC APPLICATION SECURTY TESTING - Semgrep)  
    # Scans your rect code for vulnerabilities
    - name: SAST with Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >- 
          p/javascript
          p/typescript
          p/react
          p/owasp-top-ten
          p/security-audit  
        exit-code: '1'  # Fail the job if issues are found

    #stage 4 Setup Docker Buildx( required for advanced caching)
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    #stage 5: Build Phase (With caching)
    - name: Build Fat Image 
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile
        load: true  #  keep image local (dont push yet) so we can scan it # this caches your layers in Github Actions
        tags: fat-image:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    #stage 6: Scan Phase (Security Scanning using Trivy)
    - name: Run Trivy vulnerability scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: fat-image:latest
        format: 'table'
        exit-code: '1'
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: true
        vuln-type: 'os,library'

    #stage 7: OPTIMIZATION PHASE (Using Docker Slim)/
    - name: Minify Image using SlimtoolKit
      run: |
        echo "Running SlimToolkit..."
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          dslim/slim build \
          --target fat-image:latest \
          --tag slim-image:latest \
          --http-probe=false \
          --include-path /usr/share/nginx/html 

    #stage x: DAST (Dynamic Application Security Testing - OWASP ZAP)

    # Start container to DAST
    - name: Start Application Container
      run: |
        docker run -d -p 8000:80 --name dast-container slim-image:latest
        # Wait for the application to be up and running
        sleep 10  # Adjust sleep time as necessary for your app to start
    # DAST Scan with OWASP ZAP
    - name: DAST with OWASP ZAP
      uses: zaproxy/action-full-scan@v0.8.0
      with:
        target: 'http://localhost:8000'
        fail_action: false  # Do not fail the job on alerts
        allow_issue_writing: false
    # Stop and remove the application container
    - name: Stop Application Container
      if: always()
      run: |
        docker stop dast-container
        docker rm dast-container

    #stage 3: Configure AWS Credentials
    - name: Login to AWS ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.aws_region }}

    #stage 4: Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    #stage 8: Push Phase
    - name: Push Optimized Image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Retagging local slim image for ECR..."
          
        # 1. Tag 'slim-image' with the ECR Format + SHA
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        
        # 2. Tag 'slim-image' with ECR Format + latest
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # 3. Push
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "::notice::ðŸš€ Deployed Optimized Image: $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}"