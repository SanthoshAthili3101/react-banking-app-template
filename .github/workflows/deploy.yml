name: React App Deployment

# Triggers
on:
  push:
    branches: [master]

  # Allows you to run this manually from the Actions tab for debugging
  workflow_dispatch:

# Concurrency (it will delete the exisiting pipeline runs if a new one is triggered)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Global environment variables
env:
  aws_region: ap-south-1
  ECR_REPOSITORY:  react-banking-app
  IMAGE_TAG: ${{ github.sha }}
  ECS_SERVICE: banking-app-service
  ECS_CLUSTER: banking-cluster
  ECS_TASK_DEFINITION: .aws/task-definition.json # We will create a dummy placeholder for this
  CONTAINER_NAME: banking-app-container

# Permissions
permissions:
  contents: read
  security-events: write # For uploading scan results to GitHub 

# Jobs
jobs:
  build-secure-deploy:
    name: Build, Secure, Optimize and Deploy 
    runs-on: ubuntu-latest

    steps:

    #stage 1: Checkout Code
    # It fetches your repository under $GITHUB_WORKSPACE, so your job can access it
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for accurate SHA tagging and to scan all commits
    
    # Stage 2: Secret Scanning (TruffleHog)
    # Checks git history for leaked AWS keys, tokens, etc.
    - name: Secret Scanning with TruffleHog
      uses: trufflesecurity/trufflehog@v3.90.2
      with:
        extra_args: --only-verified


    # - name: Upload TruffleHog Results to GitHub Security
    #   uses: github/codeql-action/upload-sarif@v3
    #   if: always()
    #   with:
    #     sarif_file: ${{ steps.trufflehog.outputs.sarif }} # The output variable from the TruffleHog action
    #     category: trufflehog

    # Stage 3: SAST(STATIC APPLICATION SECURTY TESTING - Semgrep)  
    # Scans your rect code for vulnerabilities
    - name: SAST with Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >- 
          p/javascript
          p/typescript
          p/react
          p/owasp-top-ten
          p/security-audit
        generateSarif: true
        sarif: semgrep.sarif  
    
    # Upload Semgrep results to GitHub Security Tab
    - name: Upload Semgrep Report
      uses: github/codeql-action/upload-sarif@v3
      if: always() 
      with:
        sarif_file: semgrep.sarif
        category: semgrep

    # Stage 4: IaC Scanning (Trivy)      
    # Scans your Infrastructure as Code (Terraform & Dockerfile) for misconfigurations
    - name: Run Trivy IaC Scan (Terraform & Dockerfile)
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'config'        
        scan-ref: '.'             
        format: 'sarif'
        output: 'trivy-iac.sarif'
        exit-code: '1'            
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: true
    
    - name: Upload Trivy IaC Report
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-iac.sarif'
        category: trivy-iac

    #stage 4 Setup Docker Buildx(required for advanced caching)
    # Buildx is a Docker CLI plugin that extends the docker command with the full support of the features provided by Moby BuildKit builder toolkit
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    #stage 5: Build Phase (With caching)
    # Build the Docker image with caching to speed up subsequent builds
    - name: Build Fat Image 
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile
        load: true  #  keep image local (dont push yet) so we can scan it # this caches your layers in Github Actions
        tags: fat-image:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    #stage 6: Scan Phase (Security Scanning using Trivy)
    # Scans the built Docker image for vulnerabilities
    - name: Run Trivy vulnerability scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: fat-image:latest
        format: 'sarif'
        output: 'trivy-image.sarif'
        exit-code: '1'
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: true
        vuln-type: 'os,library'

    - name: Upload Trivy Image Report
      uses: github/codeql-action/upload-sarif@v3
      if: always()
      with:
        sarif_file: 'trivy-image.sarif'
        category: trivy-image

    # Stage 7: OPTIMIZATION PHASE (Using Docker Slim)
    # Minifies the Docker image to reduce its size and attack surface
    - name: Minify Image using SlimToolkit
      run: |
        echo "Running SlimToolkit..."
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          dslim/slim build \
          --target fat-image:latest \
          --tag slim-image:latest \
          --http-probe=false \
          --include-path /usr/share/nginx/html \
          --include-path /etc/nginx \
          --include-path /var/cache/nginx \
          --include-path /var/log/nginx \
          --include-path /var/run \
          --include-path /etc/passwd \
          --include-path /etc/group \
          --include-bin /usr/sbin/nginx

    #stage 8: DAST (Dynamic Application Security Testing - OWASP ZAP)

    # Start container to DAST
    - name: Start Application Container
      run: |
        # MAP PORT 8080 (Host) -> 8080 (Container)
        docker run -d -p 8080:8080 --name dast-container slim-image:latest

    # Wait for the application to be ready
    - name: Wait for App to be Ready
      run: |
        echo "Waiting for application to start..."
        timeout 60s bash -c 'until curl -s http://localhost:8080 > /dev/null; do sleep 2; done'
        echo "Application is UP!"

    # To degug DAST issues, capture logs if the scan fails
    - name: Debug Container Logs (On Failure)
      if: failure() # Only runs if the previous step failed
      run: |
        echo "=== CONTAINER LOGS ==="
        docker logs dast-container
        echo "=== CONTAINER INSPECT ==="
        docker inspect dast-container

    # DAST Scan with OWASP ZAP
    - name: DAST with OWASP ZAP
      uses: zaproxy/action-full-scan@v0.13.0
      with:
        target: 'http://localhost:8080'
        fail_action: false  # Do not fail the job on alerts
        allow_issue_writing: false

    # Stop and remove the application container
    - name: Stop Application Container
      if: always()
      run: |
        docker stop dast-container
        docker rm dast-container

    #stage 9: Configure AWS Credentials
    # Configures AWS credentials for subsequent AWS actions
    - name: Login to AWS ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.aws_region }}

    #stage 10: Login to Amazon ECR
    # Logs in to Amazon ECR to enable pushing images
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    #stage 11: Push Phase
    # Pushes the optimized Docker image to Amazon ECR
    - name: Push Optimized Image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Retagging local slim image for ECR..."
          
        # 1. Tag 'slim-image' with the ECR Format + SHA
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        
        # 2. Tag 'slim-image' with ECR Format + latest
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # 3. Push
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "::notice::ðŸš€ Deployed Optimized Image: $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}"

    # # STAGE 12: CONTINUOUS DEPLOYMENT (ECS Fargate)
    # # Deploys the new image to Amazon ECS Fargate

    # # Download the current task definition
    # - name: Download Task Definition
    #   run: |
    #     # Fetch the CURRENT Task Definition from AWS
    #     aws ecs describe-task-definition --task-definition banking-app-task \
    #     --query taskDefinition > task-definition.json

    # # Fill in the new image ID in the task definition
    # - name: Fill in the new image ID in the Amazon ECS task definition
    #   id: task-def
    #   uses: aws-actions/amazon-ecs-render-task-definition@v1
    #   with:
    #     task-definition: task-definition.json
    #     container-name: ${{ env.CONTAINER_NAME }}
    #     image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}
    # # Deploy the new task definition to the ECS service
    # - name: Deploy Amazon ECS task definition
    #   uses: aws-actions/amazon-ecs-deploy-task-definition@v1
    #   with:
    #     task-definition: ${{ steps.task-def.outputs.task-definition }}
    #     service: ${{ env.ECS_SERVICE }}
    #     cluster: ${{ env.ECS_CLUSTER }}
    #     wait-for-service-stability: true