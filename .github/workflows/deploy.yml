name: React App Deployment

# Triggers
on:
  push:
    branches: [master]

  # Allows you to run this manually from the Actions tab for debugging
  workflow_dispatch:

# Concurrency (it will delete the exisiting pipeline runs if a new one is triggered)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Global environment variables
env:
  aws_region: ap-south-1
  ECR_REPOSITORY:  react-banking-app
  IMAGE_TAG: ${{ github.sha }}

# Permissions
permissions:
  contents: read
  security-events: write # For uploading scan results to GitHub 

# Jobs
jobs:
  build-secure-deploy:
    name: Build, Secure, Optimize and Deploy 
    runs-on: ubuntu-latest

    steps:
    #stage 1: Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for accurate SHA tagging and to scan all commits
    
    # Stage 2: Secret Scanning (TruffleHog)
    # Checks git history for leaked AWS keys, tokens, etc.
    - name: Secret Scanning with TruffleHog
      uses: trufflesecurity/trufflehog@v3.90.2
      with:
        extra_args: --only-verified

    # Stage 3: SAST( STATIC APPLICATION SECURTY TESTING - Semgrep)  
    # Scans your rect code for vulnerabilities
    - name: SAST with Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >- 
          p/javascript
          p/typescript
          p/react
          p/owasp-top-ten
          p/security-audit  

    #stage 4 Setup Docker Buildx( required for advanced caching)
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    #stage 5: Build Phase (With caching)
    - name: Build Fat Image 
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile
        load: true  #  keep image local (dont push yet) so we can scan it # this caches your layers in Github Actions
        tags: fat-image:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    #stage 6: Scan Phase (Security Scanning using Trivy)
    - name: Run Trivy vulnerability scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: fat-image:latest
        format: 'table'
        exit-code: '1'
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: true
        vuln-type: 'os,library'

    # Stage 7: OPTIMIZATION PHASE (Using Docker Slim)
    - name: Minify Image using SlimToolkit
      run: |
        echo "Running SlimToolkit..."
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          dslim/slim build \
          --target fat-image:latest \
          --tag slim-image:latest \
          --http-probe=false \
          --include-path /opt/bitnami \
          --include-path /usr/share/nginx/html \
          --include-path /usr/lib \
          --include-path /lib \
          --include-path /lib64 \
          --include-bin /bin/bash \
          --include-bin /usr/bin/date \
          --include-bin /usr/bin/cp \
          --include-bin /usr/bin/mkdir \
          --include-bin /usr/bin/cat \
          --include-bin /usr/bin/grep \
          --include-bin /usr/bin/sed \
          --include-bin /usr/bin/awk

    #stage x: DAST (Dynamic Application Security Testing - OWASP ZAP)

    # Start container to DAST
    - name: Start Application Container
      run: |
        docker run -d -p 8080:8080 --name dast-container slim-image:latest

    - name: Wait for App to be Ready
      # FIX: Loop until the app responds (Health Check)
      run: |
        echo "Waiting for application to start..."
        timeout 200s bash -c 'until curl -s http://localhost:8080 > /dev/null; do sleep 2; done'
        echo "Application is UP!"
    - name: Debug Container Logs (On Failure)
      if: failure() # Only runs if the previous step failed
      run: |
        echo "=== CONTAINER LOGS ==="
        docker logs dast-container
        echo "=== CONTAINER INSPECT ==="
        docker inspect dast-container

    # DAST Scan with OWASP ZAP
    - name: DAST with OWASP ZAP
      uses: zaproxy/action-full-scan@v0.13.0
      with:
        target: 'http://localhost:8080'
        fail_action: false  # Do not fail the job on alerts
        allow_issue_writing: false

    # Stop and remove the application container
    - name: Stop Application Container
      if: always()
      run: |
        docker stop dast-container
        docker rm dast-container

    #stage 3: Configure AWS Credentials
    - name: Login to AWS ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.aws_region }}

    #stage 4: Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    #stage 8: Push Phase
    - name: Push Optimized Image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Retagging local slim image for ECR..."
          
        # 1. Tag 'slim-image' with the ECR Format + SHA
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        
        # 2. Tag 'slim-image' with ECR Format + latest
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # 3. Push
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "::notice::ðŸš€ Deployed Optimized Image: $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}"