name: React App Deployment

# Triggers
on:
  push:
    branches: [master]

  # Allows you to run this manually from the Actions tab for debugging
  workflow_dispatch:

# Concurrency (it will delete the exisiting pipeline runs if a new one is triggered)
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

# Global environment variables
env:
  aws_region: ap-south-1
  ECR_REPOSITORY:  react-banking-app
  IMAGE_TAG: ${{ github.sha }}
  ECS_SERVICE: banking-app-service
  ECS_CLUSTER: banking-cluster
  ECS_TASK_DEFINITION: .aws/task-definition.json # We will create a dummy placeholder for this
  CONTAINER_NAME: banking-app-container

# Permissions
permissions:
  contents: read
  security-events: write # For uploading scan results to GitHub 
#Just add permissions for aws user

# Jobs
jobs:
  build-secure-deploy:
    name: Build, Secure, Optimize and Deploy 
    runs-on: ubuntu-latest

    steps:
    #stage 1: Checkout Code
    - name: Checkout Code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for accurate SHA tagging and to scan all commits
    
    # Stage 2: Secret Scanning (TruffleHog)
    # Checks git history for leaked AWS keys, tokens, etc.
    - name: Secret Scanning with TruffleHog
      uses: trufflesecurity/trufflehog@v3.90.2
      with:
        extra_args: --only-verified

    # Stage 3: SAST( STATIC APPLICATION SECURTY TESTING - Semgrep)  
    # Scans your rect code for vulnerabilities
    - name: SAST with Semgrep
      uses: returntocorp/semgrep-action@v1
      with:
        config: >- 
          p/javascript
          p/typescript
          p/react
          p/owasp-top-ten
          p/security-audit  

    #stage 4 Setup Docker Buildx( required for advanced caching)
    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    #stage 5: Build Phase (With caching)
    - name: Build Fat Image 
      uses: docker/build-push-action@v5
      with:
        context: .
        file: Dockerfile
        load: true  #  keep image local (dont push yet) so we can scan it # this caches your layers in Github Actions
        tags: fat-image:latest
        cache-from: type=gha
        cache-to: type=gha,mode=max

    #stage 6: Scan Phase (Security Scanning using Trivy)
    - name: Run Trivy vulnerability scan
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: fat-image:latest
        format: 'table'
        exit-code: '1'
        severity: 'CRITICAL,HIGH'
        ignore-unfixed: true
        vuln-type: 'os,library'

    # Stage 7: OPTIMIZATION PHASE (Using Docker Slim)
    - name: Minify Image using SlimToolkit
      run: |
        echo "Running SlimToolkit..."
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          dslim/slim build \
          --target fat-image:latest \
          --tag slim-image:latest \
          --http-probe=false \
          --include-path /usr/share/nginx/html \
          --include-path /etc/nginx \
          --include-path /var/cache/nginx \
          --include-path /var/log/nginx \
          --include-path /var/run \
          --include-path /etc/passwd \
          --include-path /etc/group \
          --include-bin /usr/sbin/nginx

    #stage x: DAST (Dynamic Application Security Testing - OWASP ZAP)

    # Start container to DAST
    - name: Start Application Container
      run: |
        # MAP PORT 8080 (Host) -> 80 (Container)
        docker run -d -p 8080:80 --name dast-container slim-image:latest

    - name: Wait for App to be Ready
      run: |
        echo "Waiting for application to start..."
        # 60s timeout is plenty for Alpine
        timeout 60s bash -c 'until curl -s http://localhost:8080 > /dev/null; do sleep 2; done'
        echo "Application is UP!"
    - name: Debug Container Logs (On Failure)
      if: failure() # Only runs if the previous step failed
      run: |
        echo "=== CONTAINER LOGS ==="
        docker logs dast-container
        echo "=== CONTAINER INSPECT ==="
        docker inspect dast-container

    # DAST Scan with OWASP ZAP
    - name: DAST with OWASP ZAP
      uses: zaproxy/action-full-scan@v0.13.0
      with:
        target: 'http://localhost:8080'
        fail_action: false  # Do not fail the job on alerts
        allow_issue_writing: false

    # Stop and remove the application container
    - name: Stop Application Container
      if: always()
      run: |
        docker stop dast-container
        docker rm dast-container

    #stage 3: Configure AWS Credentials
    - name: Login to AWS ECR
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.aws_region }}

    #stage 4: Login to Amazon ECR
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    #stage 8: Push Phase
    - name: Push Optimized Image to ECR
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "Retagging local slim image for ECR..."
          
        # 1. Tag 'slim-image' with the ECR Format + SHA
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        
        # 2. Tag 'slim-image' with ECR Format + latest
        docker tag slim-image:latest $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        # 3. Push
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "::notice::ðŸš€ Deployed Optimized Image: $ECR_REGISTRY/$ECR_REPOSITORY:${{ env.IMAGE_TAG }}"

    # ----------------------------------------------------------------
    # STAGE 6: CONTINUOUS DEPLOYMENT (ECS Fargate)
    # ----------------------------------------------------------------
    - name: Download Task Definition
      run: |
        # Fetch the CURRENT Task Definition from AWS
        aws ecs describe-task-definition --task-definition banking-app-task \
        --query taskDefinition > task-definition.json

    - name: Fill in the new image ID in the Amazon ECS task definition
      id: task-def
      uses: aws-actions/amazon-ecs-render-task-definition@v1
      with:
        task-definition: task-definition.json
        container-name: ${{ env.CONTAINER_NAME }}
        # Use the ECR image we just pushed
        image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ env.IMAGE_TAG }}

    - name: Deploy Amazon ECS task definition
      uses: aws-actions/amazon-ecs-deploy-task-definition@v1
      with:
        task-definition: ${{ steps.task-def.outputs.task-definition }}
        service: ${{ env.ECS_SERVICE }}
        cluster: ${{ env.ECS_CLUSTER }}
        wait-for-service-stability: true